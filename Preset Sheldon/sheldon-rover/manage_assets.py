import csv
import os
import sys

# Add current directory to path so we can import lines_sheldon
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from lines_sheldon import LINES

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
ASSETS_DIR = os.path.join(BASE_DIR, 'assets')
AUDIO_DIR = os.path.join(ASSETS_DIR, 'audio')
DATABASE_FILE = os.path.join(ASSETS_DIR, 'database.csv')

# Category mapping for serial commands (Base IDs)
CATEGORY_MAP = {
    "BOOT": 100,
    "MOVE_START": 200,
    "COLLISION": 300,
    "STUCK": 400,
    "IDLE_TOO_LONG": 500,
    "RESET": 600,
    "MOVE_STOP": 700,
    "MODE_SWITCH": 800
}

ESP_DIST_DIR = os.path.join(ASSETS_DIR, 'esp32_dist')
HEADER_FILE = os.path.join(ESP_DIST_DIR, 'audio_map.h')


def generate_id(category, intensity, index):
    return f"{category}_{intensity}_{index}"

def generate_serial_command(category, intensity, index):
    base = CATEGORY_MAP.get(category, 900)
    # Mapping: Base + (Intensity * 10) + Index
    # Example: BOOT (100) + Med (1 * 10) + 0 = 110
    return base + (intensity * 10) + index

def get_audio_filename(category, intensity, index):
    # Standardized filename: bo_1_0.wav (shortened for older filesystems if needed, but keeping descriptive for now)
    # Let's stick to safe lowercase chars
    cat_short = category.lower()
    return f"{cat_short}_{intensity}_{index}.wav"

def load_existing_db():
    if not os.path.exists(DATABASE_FILE):
        return {}
    
    db = {}
    with open(DATABASE_FILE, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            db[row['id']] = row
    return db

def sync_database():
    print("Syncing database with lines_sheldon.py...")
    existing_db = load_existing_db()
    new_rows = []
    
    # Define columns
    fieldnames = ['id', 'category', 'intensity', 'index', 'serial_command', 'audio_filename', 'transcript', 'file_exists']

    for category, intensities in LINES.items():
        for intensity, lines in intensities.items():
            for index, text in enumerate(lines):
                row_id = generate_id(category, intensity, index)
                
                # Default values
                row = {
                    'id': row_id,
                    'category': category,
                    'intensity': intensity,
                    'index': index,
                    'serial_command': generate_serial_command(category, intensity, index),
                    'audio_filename': get_audio_filename(category, intensity, index),
                    'transcript': text,
                    'file_exists': "FALSE"
                }

                # If exists, preserve custom fields if we had them (not applicable yet, but good practice)
                # For now, just overwrite to ensure sync, or check if we want to preserve manual changes?
                # Let's assume the code is the source of truth for structure, CSV for metadata.
                
                if row_id in existing_db:
                    # Update transcript in case code changed, keep filename if user changed it
                    existing_row = existing_db[row_id]
                    row['audio_filename'] = existing_row.get('audio_filename', row['audio_filename'])
                
                # Check actual file existence
                full_path = os.path.join(AUDIO_DIR, row['audio_filename'])
                row['file_exists'] = str(os.path.exists(full_path)).upper()
                
                new_rows.append(row)

    # Write back to CSV
    with open(DATABASE_FILE, 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(new_rows)
    print(f"Database updated! {len(new_rows)} entries written to {DATABASE_FILE}")
    return new_rows

def export_esp32(db_rows):
    if not os.path.exists(ESP_DIST_DIR):
        os.makedirs(ESP_DIST_DIR)
    
    print("Exporting for ESP32...")
    
    # Sort by serial command for cleanliness
    sorted_rows = sorted(db_rows, key=lambda x: int(x['serial_command']))
    
    header_content = """#ifndef AUDIO_MAP_H
#define AUDIO_MAP_H

// Auto-generated by manage_assets.py

struct AudioAsset {
    int command;
    const char* filename;
};

const AudioAsset AUDIO_ASSETS[] = {
"""
    
    for row in sorted_rows:
        header_content += f"    {{ {row['serial_command']}, \"/{row['audio_filename']}\" }},\n"
        
    header_content += """    { -1, "" } // Sentinel
};

#endif // AUDIO_MAP_H
"""

    with open(HEADER_FILE, 'w') as f:
        f.write(header_content)
        
    print(f"Generated {HEADER_FILE}")

def main():
    if not os.path.exists(ASSETS_DIR):
        os.makedirs(ASSETS_DIR)
    if not os.path.exists(AUDIO_DIR):
        os.makedirs(AUDIO_DIR)
        
    rows = sync_database()
    export_esp32(rows)

if __name__ == "__main__":
    main()
