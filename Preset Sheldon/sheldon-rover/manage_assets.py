import shutil
import re
import sys
import os
import csv
from difflib import SequenceMatcher


# Add current directory to path so we can import lines_sheldon


# Add current directory to path so we can import lines_sheldon

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from lines_sheldon import LINES

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
ASSETS_DIR = os.path.join(BASE_DIR, 'assets')
AUDIO_DIR = os.path.join(ASSETS_DIR, 'audio')
DATABASE_FILE = os.path.join(ASSETS_DIR, 'database.csv')

# Category mapping for serial commands (Base IDs)
CATEGORY_MAP = {
    "BOOT": 100,
    "MOVE_START": 200,
    "COLLISION": 300,
    "STUCK": 400,
    "IDLE_TOO_LONG": 500,
    "RESET": 600,
    "MOVE_STOP": 700,
    "RESET": 600,
    "MOVE_STOP": 700,
    "MODE_SWITCH": 800,
    "SAW_HUMAN": 900,
    "RANDOM": 950
}


ESP_DIST_DIR = os.path.join(ASSETS_DIR, 'esp32_dist')
HEADER_FILE = os.path.join(ESP_DIST_DIR, 'audio_map.h')


def generate_id(category, intensity, index):
    return f"{category}_{intensity}_{index}"

def generate_serial_command(category, intensity, index):
    base = CATEGORY_MAP.get(category, 900)
    # Mapping: Base + (Intensity * 10) + Index
    # Example: BOOT (100) + Med (1 * 10) + 0 = 110
    return base + (intensity * 10) + index

def get_audio_filename(category, intensity, index):
    # Standardized filename: bo_1_0.wav (shortened for older filesystems if needed, but keeping descriptive for now)
    # Let's stick to safe lowercase chars
    cat_short = category.lower()
    return f"{cat_short}_{intensity}_{index}.wav"

def load_existing_db():
    if not os.path.exists(DATABASE_FILE):
        return {}
    
    db = {}
    with open(DATABASE_FILE, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            db[row['id']] = row
    return db

def sync_database():
    print("Syncing database with lines_sheldon.py...")
    existing_db = load_existing_db()
    new_rows = []
    
    # Define columns
    fieldnames = ['id', 'category', 'intensity', 'index', 'serial_command', 'audio_filename', 'transcript', 'file_exists']

    for category, intensities in LINES.items():
        for intensity, lines in intensities.items():
            for index, text in enumerate(lines):
                row_id = generate_id(category, intensity, index)
                
                # Default values
                row = {
                    'id': row_id,
                    'category': category,
                    'intensity': intensity,
                    'index': index,
                    'serial_command': generate_serial_command(category, intensity, index),
                    'audio_filename': get_audio_filename(category, intensity, index),
                    'transcript': text,
                    'file_exists': "FALSE"
                }

                # If exists, preserve custom fields if we had them (not applicable yet, but good practice)
                # For now, just overwrite to ensure sync, or check if we want to preserve manual changes?
                # Let's assume the code is the source of truth for structure, CSV for metadata.
                
                if row_id in existing_db:
                    # Update transcript in case code changed, keep filename if user changed it
                    existing_row = existing_db[row_id]
                    row['audio_filename'] = existing_row.get('audio_filename', row['audio_filename'])
                
                # Check actual file existence
                full_path = os.path.join(AUDIO_DIR, row['audio_filename'])
                row['file_exists'] = str(os.path.exists(full_path)).upper()
                
                new_rows.append(row)

    # Write back to CSV
    with open(DATABASE_FILE, 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(new_rows)
    print(f"Database updated! {len(new_rows)} entries written to {DATABASE_FILE}")
    return new_rows

def export_esp32(db_rows):
    if not os.path.exists(ESP_DIST_DIR):
        os.makedirs(ESP_DIST_DIR)
    
    print("Exporting for ESP32...")
    
    # Sort by serial command for cleanliness
    sorted_rows = sorted(db_rows, key=lambda x: int(x['serial_command']))
    
    header_content = """#ifndef AUDIO_MAP_H
#define AUDIO_MAP_H

// Auto-generated by manage_assets.py

struct AudioAsset {
    int command;
    const char* filename;
};

const AudioAsset AUDIO_ASSETS[] = {
"""
    
    for row in sorted_rows:
        header_content += f"    {{ {row['serial_command']}, \"/{row['audio_filename']}\" }},\n"
        
    header_content += """    { -1, "" } // Sentinel
};

#endif // AUDIO_MAP_H
"""

    with open(HEADER_FILE, 'w') as f:
        f.write(header_content)
        
    print(f"Generated {HEADER_FILE}")

def normalize_text(text):
    return re.sub(r'[^a-z0-9]', '', text.lower())

def import_loose_files(db_rows):
    print("Scanning for loose audio files...")
    # Scan root directory (up two levels from assets/audio: assets/audio -> assets -> sheldon-rover -> root)
    # Wait, BASE_DIR is sheldon-rover. User said "files in the preset sheldon folder".
    # Existing structure: runtime_terr/Preset Sheldon/sheldon-rover/manage_assets.py
    # User's ls showed files in runtime_terr directly?
    # "find . -maxdepth 3" showed files in "Preset Sheldon/sheldon-rover/" but the LS command in thought block showed files like "./you're doooooooomed.mp3".
    # Let's search in ../../ (runtime_terr) and ../ (Preset Sheldon) from BASE_DIR?
    # Actually, the LS output showing files at ./ meant they were in the CWD of the command.
    # The command CWD was /Users/manya/Desktop/runtime_terr.
    # So files are in runtime_terr.
    
    root_search_path = os.path.dirname(os.path.dirname(BASE_DIR)) # runtime_terr
    
    # Also check current dir just in case
    search_paths = [root_search_path, BASE_DIR]
    
    candidates = []
    for path in search_paths:
        if not os.path.exists(path): continue
        for user_file in os.listdir(path):
            if user_file.lower().endswith(('.mp3', '.wav', '.m4a', '.mov')):
                candidates.append((path, user_file))
                
    if not candidates:
        print("No loose audio files found.")
        return db_rows

    updates_count = 0
    
    for row in db_rows:
        if row['file_exists'] == "TRUE":
            continue
            
        transcript_norm = normalize_text(row['transcript'])
        best_match = None
        best_score = 0.0
        
        for path, filename in candidates:
            # Check if this file is already claimed? (Simplified: no, assume 1-to-1 best match)
            # Normalize filename body
            file_body = os.path.splitext(filename)[0]
            file_norm = normalize_text(file_body)
            
            # Substring check first
            if transcript_norm in file_norm or file_norm in transcript_norm:
                score = 0.8 + (0.2 * (len(transcript_norm) / len(file_norm) if len(file_norm) > 0 else 0))
            else:
                score = SequenceMatcher(None, transcript_norm, file_norm).ratio()
                
            if score > 0.6 and score > best_score:
                best_match = (path, filename)
                best_score = score
        
        if best_match and best_score > 0.6:
            src_path, src_filename = best_match
            ext = os.path.splitext(src_filename)[1].lower()
            
            # Rename extension in DB to match actual file if different
            target_filename = os.path.splitext(row['audio_filename'])[0] + ext
            row['audio_filename'] = target_filename
            
            full_src = os.path.join(src_path, src_filename)
            full_dest = os.path.join(AUDIO_DIR, target_filename)
            
            print(f"Importing: '{src_filename}' -> '{target_filename}' (Match: {int(best_score*100)}%)")
            shutil.move(full_src, full_dest)
            row['file_exists'] = "TRUE"
            updates_count += 1
            
            # Remove from candidates so it's not reused
            candidates.remove(best_match)

    if updates_count > 0:
        # Re-save DB to update extensions
        fieldnames = ['id', 'category', 'intensity', 'index', 'serial_command', 'audio_filename', 'transcript', 'file_exists']
        with open(DATABASE_FILE, 'w', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(db_rows)
            
    return db_rows

def main():
    if not os.path.exists(ASSETS_DIR):
        os.makedirs(ASSETS_DIR)
    if not os.path.exists(AUDIO_DIR):
        os.makedirs(AUDIO_DIR)
        
    rows = sync_database()
    rows = import_loose_files(rows)
    export_esp32(rows)

if __name__ == "__main__":
    main()
